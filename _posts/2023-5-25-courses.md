---
layout: page
title: Comprehensive Cornell Course Reviews
---
## Introduction
<!-- Similar pages at CMU: 
[1](https://wanshenl.me/courses/), 
[2](https://weihang7.github.io/courses/),
[3](https://ruiran.me/courses/),
[4](https://hachiyuki8.github.io/cmu/course-reviews),
[5](https://fanpu.io/courses/) -->

My thoughts on Cornell Courses I've taken. My experiences may differ from others due to the strict Covid-19 restrictions and virtual classes during my freshman year. The choice of classes I took and enjoyed mainly reflects my interest in computer systems rather than the more theoretical side of computer science.

I want to preface that the number of credits an average Cornell student takes is around 15 academic credits. I took 1-2 additional classes per semester compared to the average engineering student. Additionally, credit hours can be deceiving as some classes are much more work than their credits entail and vice versa. 

Entering my junior year, I had a mentality shift where I started dedicating more time to the class I enjoyed rather than just getting requirements out of the way.

üëç indicates a class I really enjoyed.

‚≠ê indicates a transformative class I strongly recommend taking.

Semester Difficulty Ratings: {easy, medium, hard, death}.  
Rated in terms of how stressed I was feeling on average throughout the semester.

Background:
- Intended Major
    - I came in as an ECE major in the College of Engineering
- Programming Background
    - I didn't touch a single line of code coming into Cornell
- Math Background
    - I did a subset of Multi-Variable Calculus in high school
    - I didn't participate much for competition math.
    
##### Degree: 
B.S, M.Eng in Computer Science 

College of Engineering

##### GPA: 
4.1/4.0

##### AP Transfer Credit:
- AP CALC BC 5: Math 1910 Credit
- AP CHEM 5: Chem 2090 Credit
- AP Microeconomics 5: 3 Liberal Studies Credit (ECON 1110)
- AP Macroeconomics 5: 3 Liberal Studies Credit (ECON 1120)
- AP BIO 4 üò≠ Covid Spring: 4 credits for Advisor Approved Electives could've been 8
- 10 other APs 5 that were all no credit

## Fall 2020 Difficulty: Medium
- __Math 1920: Multivariable Calculus for Engineers__  
    <span style="color:grey">Reyer Sjamaar</span>

    Given that I had taken a simpler version of Multivariable Calculus in high school, the first half of the class was relatively simple. I did every problem in the textbook to ensure I understood the foundations of our learning. I finished over seven notebooks of writing just for homework, practice problems, and exams. The latter half of the course was new material and required much more thought and time to understand what was happening. Overall, an excellent introduction to my first college-level math course.

- __‚≠ê CS 1110: Intro Computing Using Python__  
    <span style="color:grey">Walker White</span>

    One of, if not the best introductory courses in computing (Fall Version with Professor Walker White). Although I never scored the high 90s on my exams, the foundational concepts, the weekly labs, projects, and lectures kept me motivated throughout the semester. Professor White made short 10-minute videos multiple times a week teaching the new topics covered and reinforced those ideas during the three lectures a week. The combination of self-studying alongside examples during lectures accelerated the rate of learning I achieved throughout the semester. Additionally, the class and projects were well structured, which helped people without any background in computer science. Each week we would cover new topics such as basic operators, objects, lists, and even generators.

    One regret I have is working with partners within the class. The projects aren't nearly large enough to warrant splitting up the work, and given that CS 1110 is an intro class, it takes away from an individual's learning. Through the projects, people should be encouraged to learn the core concepts. I routinely learned much more by debugging through tasks rather than immediately giving up, going to office hours, or asking my partner. The projects I worked alone on were far better learning experiences. 

    Another issue I observed is that students with AP credit are exempt from taking this class, which is unfortunate. In my opinion, CS 2110, the subsequent course, doesn't do as good a job teaching the material. On the other hand, many students who end up taking CS 1110 do not fully leverage the potential of the class due to their lack of commitment and effort in learning the material because CS 1110 is a required class. Even many potential CS majors who take the class don't take the class seriously, which severely hampers their foundational understanding for future CS classes.

    Despite the challenges posed by virtual learning, CS 1110 has played a pivotal role in cultivating my interest in Computer Science, thanks to its excellent teaching methods. I firmly believe that it stands out as one of the most well-taught classes offered at Cornell University. The core principles of debugging and computing, which I learned in this class, continue to resonate with me and greatly benefit my ongoing studies.

- __ENGRG 1010: AEW Collab Workshop: CS 1110__  
    <span style="color:grey">Undergrad student</span>

    There were weekly meetings where we would fill out a sheet based on what we learned in CS 1110 that week. Overall, I don't think it impacted my grade in CS 1110 or my understanding of CS, but it was always more helpful to do more practice problems. It was all online in a Zoom breakout room, so it was not very interactive. AEWs might be better now that everything is back in person, so your mileage may vary.

- __ENGRG 1050: Engineering Seminar__  
    <span style="color:grey">Undergrad student</span>

    Introductory Seminar that all Engineers have to take. The class has a weekly meeting where you meet those sitting with you and talk about courses to take, major decisions, and opportunities on campus. I don't think it was of much use, but it is still a requirement for everyone.
- __HIST 1200: FWS: Writing History__  
    <span style="color:grey">PHD student</span>

    I wrote about 4-5 essays throughout the entire semester. It was a relatively politically driven class. It was a moderate amount of work throughout the semester, with weekly attendance, group discussions, and essays. I needed it for FWS credit. I would say most FWS are a random coin toss. It is hard to say whether or not you will get an easy or hard one. 

- __PHYS 1112: Physics 1: Mechanics & Heat__  
    <span style="color:grey">Phillip Krasicky</span>

    Similar to Math 1920, I did a lot of the practice problems that were provided to make sure I had a strong foundational understanding of the topics. I think this is the easier of the two Engineering physics requirements. The class mainly consisted of weekly problem sets, discussions, and labs. The workload was moderately heavy, but it wasn't too difficult. 

- __PSYCH 1101: Introduction to Pyschology__  
    <span style="color:grey">David Pizarro</span>

    I believe they heavily nerfed this class because of Covid. It is a fall-only class and was the first time being run with Covid. As a result, there were no exams and only a weekly quiz. All I would do was watch the weekly 1-hour lecture at 3x speed 30 minutes before the quiz. I would then use my short-term memory to remember and answer all the quiz questions. I don't think the class could get any easier. However, exams have now returned, so the class might not be as easy as it used to be. Even then, I think a lot of good material was covered in that class, and I would still recommend taking it as a liberal study.

### Reflection

Credits: 20

This semester was a relatively smooth semester for me. Since a large chunk of the student population didn't come to school in person, many of my days consisted of sitting in my room and listening to Zoom lectures. As a result, I didn't do much other than study, which may have made the classes easier because of the time I had on my hands. I talked to several other students online because many weren't at school, and I met them the following semester. Overall, CS 1110 was the highlight of the semester, which pushed me to keep exploring Computer Science in future semesters.

## Spring 2021 Difficulty: Hard
- __BIOEE 1640: FWS: Topics in Ecology and Evolutionary Biology__  
    <span style="color:grey">PHD student</span>

    Like last semester's FWS, I wrote 4-5 essays for this class. Throughout the semester, the class seemed more straightforward than my other FWS, only for my grade in this class to be lower. Looking back, I don't know why I wanted an in-person FWS class, given that nobody interacted with each other. Furthermore, the grade I received and the work I did for the class only reinforced my idea that the FWS you chose was a toss-up. Many FWS classes are no work and give high grades, and many work you to the grave for a terrible grade. I don't know if it's the best system for Engineers, but I don't have a great alternative. 

- __üëç ENGRD/CS 2110: Object Oriented Programming & Data Structures__  
    <span style="color:grey">David Gries</span>

    In the fall of my freshman year, I wasn't too sure what I wanted to major in. Additionally, I had done pretty well in CS 1110, inspiring me to take CS 2110 to keep a CS major within my possible major. In the semester I took the course, I believe it was less work than CS 1110. However, the material was slightly more complicated. I regret not spending enough time learning the core concepts of Object-Oriented Principles during class resulting in me cramming for many of the exams and quizzes rather than fully grasping the material. It wasn't until I went back through the course the following winter till I more deeply understood the nuances of Java and OOP. After going through the class again, I started to understand the material at a much higher level. While not difficult, I think I learned more from CS 1110. 
    
    The class continues to teach the foundations of Object Oriented Programming in Java by describing object-oriented principles, data structures like graphs, maps, and stacks, and algorithms that use these data structures, like Dijkstra's algorithm. Each of the six projects would reflect the topics covered in class and take 2 - 10 hours each. 
    
    Recently, CS 2110 has been made a lot more difficult with the introduction of Professor Myers teaching the course. My experience within the class compared to newer semesters might be significantly different. 
    
    Overall, I thought the bi-weekly quizzes frequently made me catch back up with the course, and the projects were ok. I think my workload this semester detracted from the potential learning I could've had within this class. If I were to go back in time, I would've spent much more time in this class learning the basics, given that I eventually became a CS major.
    
- __üëç ENGRI 1210: The Computing Technology Inside Your Smartphone__  
    <span style="color:grey">David Albonesi</span>

    Each Engineer must take an introductory engineering class in one of the engineering fields at Cornell. I'm glad the one I chose for the ECE major was well worth it. The course covered basic circuits, logic gates, and the basics of how computer hardware worked. 

    The workload consisted of weekly asynchronous videos we had to watch alongside a quiz for each of those lectures. This class further sparked my interest in the field of computer science as well as computer engineering. The exams were fair and represented the material we learned in class. I immensely enjoyed the constant reinforcement of the things we learned through weekly lectures, quizzes, and labs, which strengthened my understanding of the material. 

    Overall, this class was the highlight of my semester despite the heavy workload of my other classes. 

- __Math 2930: Differential Equations Engineers__  
    <span style="color:grey">Hadas Ritz</span>

    This class was hard. While the workload was similar to Math 1920, taking this course and all the other heavy workload classes didn't let me understand what I was learning. I continued to do a large majority of the questions within the textbook to reinforce my knowledge of the subject. However, my studying methods were not as successful for this course as other courses. Given that they were online exams, many practice exams did not reflect the difficulty and type of questions on the exam. As a result, I didn't do the best on these exams. 

    Besides the exams, there were weekly problem sets, and the workload was moderately heavy. I only took this course because, at the time, I thought I would still be an ECE major, but I changed to a CS major by the end of the semester. 

- __PE 1441: Intermediate Badminton__  
    <span style="color:grey">Michael Bryant</span>

    I enjoyed my time playing badminton twice a week. Everybody there was great to talk and play with. I met some of my friends in the class, and it was a great break from all the mental work I was doing throughout the semester. 

- __PHYS 2213: Physics II: Electromagnetism__  
    <span style="color:grey">Alan Giambattista</span>

    Like Math 2930, this class was a lot of work and conceptually tricky. For those who had AP Physics C credit, it is a robbery. The amount of content covered in this class is incomparable to AP Physics C.

    Besides the weekly problem sets, we also had four major labs throughout the semester, which ate up a lot of time. We covered basic circuits, magnetism, and various other topics that involved multi-variable calculus. This class was by far the most challenging class of the semester when incorporating the sheer amount of work and the conceptual difficulty of the topics. This was my least favorite class of the semester.

    <!-- However, I can't say that the class was all bad. I was lucky enough to land one of the select few in-person discussion sections where I met my girlfriend ‚ù§Ô∏è.  -->

- __PHYS 4484: Teaching and Learning Physics__  
    <span style="color:grey">Eric Herman</span>

    Mandatory class for first-time TAs in the physics department. The course was a drag. We had an in-person class where we would have to turn in a 500-word essay about the videos we watched in the past week. I don't think this class should only be a single credit. It wasn't hard work, but it was not very interesting.

- __ECE 2100: (Dropped)__  
    <span style="color:grey">Khurram Afridi</span>

    One of the only classes I dropped at Cornell. I was overloaded with credits this semester (25) and thought I could pull through. The class wasn't too hard, but I just ran out of time studying for my other classes. I dropped the class right before the first prelim because I had not gone to class for the past two weeks, was stressed, and had another prelim the same night. The decision to drop out was hard because it would set me back from becoming an ECE major.

- __PHYS 4485: Teaching Experience I__  
    <span style="color:grey">Jim Baker</span>

    TA Credit for Physics 1112

### Reflection

Credits: 24 -> 20

Given how well I did in freshman fall, I overloaded myself with too much work this semester. I didn't learn much because I spread myself way too thin. Each class was a lot of work, quickly taking up days of my time either studying for exams or doing weekly problem sets. Additionally, the classes that ended up being a large amount of work were not my favorite, resulting in those classes feeling even worse. Although my grades didn't get much worse, I lacked a solid foundational understanding of the one CS course I took, and it was definitely a challenging semester.

<!-- ## Summer 2021

### Reflection

#### Three Things I Learned -->

## Fall 2021 Difficulty: Death

- __BTRY 3080: Probability Models & Inference__  
    <span style="color:grey">Ahmed El Alaoui</span>

    I was quite disappointed with this class, and I'm unsure why it turned out to be such a negative experience.  It was the first time the professor taught the class, and I initially took it because I heard it was easy. I was wrong. That was the previous professor that taught the course. The class was poorly taught, even though most concepts weren't too difficult. Although the class was marketed as an introduction to probability and statistics, I had a hard time following many of the things the professor was saying throughout the course, and it seems like I wasn't the only one. 

    The exam medians were in the solid 40-50% range for the semester. However, I think the professor heavily curved the class resulting in an A- Median. While the workload was relatively minimal, with only five problem sets all semester, cramming for the exam was exceptionally difficult.

    Overall, I would not say I liked taking the class with this professor, and the class only minimally improved my probability skills. However, I think different professors might be better at teaching the class. I took another probability course to understand the basics further and get an external spec requirement out of the way in ECE 3100.

- __CS 2800: Discrete Structures__  
    <span style="color:grey">Alexandra Silva & Frans Schalekamp</span>

    The final requirement for me to affiliate with the Computer Science program was CS 2800. This course served as my introduction to proof-based classes, and I faced initial challenges as I navigated through unfamiliar territory. Set theory, in particular, delved into difficult topics for me to grasp, prompting me to seek independent study and frequent visits to office hours for assistance. However, my struggles in this class improved my ability to write proofs, which proved invaluable in CS 4820 Algorithms.
    
    Additionally, the workload of this class was weekly problem sets as well as weekly discussion sections. Many of these introduction classes are filled with problem sets that eat away at your time. CS 2800 is no different. For classes that I didn‚Äôt have any background in, it is really important to take the time to understand what you are learning foundationally. Each Computer Science topic is crucial to developing core computer science skills.
    
    The other topics covered in class, like Combinatorics, probability, DFAs, and number theory, were much more intuitive outside of set theory. Each of these concepts I had covered in different classes helped solidify my understanding of the material.
    
    A lot of people say that CS 2800 is difficult. I agree. As a strong weeder for CS majors, I believe that some of the concepts covered within CS 2800 provide a strong mathematical foundation of thinking for doing a computer science major at Cornell. While it is not my favorite class, I see the benefit of requiring all CS majors to take it.

- __üëç CS 3110: Data Structures & Functional Programming__  
    <span style="color:grey">Michael Clarkson</span>

    Like CS 2110, I wish I had put more time into this class earlier in the semester. The concepts are excellent, the methodology of thinking is different, and the projects seem very interesting. Unfortunately, I never really had the time to invest in the excellent scopes for the projects until the end of the semester. The only project I dedicated my time towards was the final Jocalf project, where I ended up doing the excellent and bonus scope of the project. Building an interpreter for language seemed very interesting and only increased my interest in taking compilers in my junior spring. 

    Besides the projects, we had weekly labs to cover new functional programming techniques we had learned in class and four mini-in-class exams during the semester. 

    Again, I went back after the semester ended to revisit many topics I didn't fully understand. I went back and did excellent scope for the Red-Black tree project and went through many of the labs again to understand functional style data structures and a programming methodology. 

    CS 3110 is a great class that can transform your perspective on programming. While the data structures we learned, such as Maps, are similar to those in CS 2110, they are implemented differently in OCaml. Incorporating various functional programming techniques, such as mapping functions over collections and utilizing functional interfaces, has influenced my day-to-day programming. Even though my team's compiler project was written in Java, we often found functional programming, particularly pattern matching, to be superior, leading us to question our decisions. I firmly believe that CS 3110 and functional programming provide crucial insights for anyone aspiring to become a programmer.

- __‚≠ê ENGRD/ECE 2300: Digital Logic & Computer Organization__  
    <span style="color:grey">Elizabeth Helbling</span>

    I enjoyed this class. Similar to ENGRI 1210, it covers basic circuits, digital logic, and computer architecture. However, it covers them all in much greater depth. The class was taught well, and my background in ENGRI 1210 helped me understand the material better. The class digs into boolean algebra, digital clocks, caches, and how the hardware works when it is executing assembly instructions. The class gives a foundational understanding of the underlying hardware of your computer and is very helpful for future systems courses.

    This class is either a core ECE class or a part of the ENGRD 2300 CS 3420 track instead of CS 3410. While I believe that ECE 2300 and CS 3410 are both great classes, CS 3420 is a letdown I will build upon in my CS 3420 section.

    Within the class, we had bi-weekly problem sets and weekly labs. These labs would all be in Verilog, where we would code up (in hardware) finite-state machines, basic ALU units, and a full single-cycle processor. The labs are randomly assigned groups of two, which can be a pain if you and your partner don't have to align work schedules. 

    Overall, I enjoyed the professor's lectures and the content of the course. Although there was a lot of work throughout the class, I constantly prioritized this class over the others because the class felt more fun and exciting compared to my other classes. I highly recommend the course for those who can take ENGRD/ECE 2300!

-  __MATH 2940: Linear Algebra for Engineers__  
    <span style="color:grey">Ed Swartz</span>

    Unlike Math 2930 last semester, I thought Math 2940 was much more manageable. The content made a lot more sense in the context of what we were learning. The workload was similar because we had weekly problem sets and exams.

	The core components of the course cover matrices. The class teaches matrix multiplication, change of base, and many other helpful tools. The class is critical for any future mathematical CS course anyone plans to take. The core concepts of matrix multiplication are fundamental in Machine Learning and Numerical Analysis. 
    
    Overall, I thought the class was relatively taught well. The in-person component of the class helped me understand the proofs and calculations that took place. However, I still ended up mostly cramming for all the exams, which may not have been the most helpful for the future Machine Learning classes I took. 

- __TA for CS 1110__  

    I started TAing for CS 1110 because I enjoyed taking the course. We hosted weekly discussion sections and had two hours of office hours. TAing CS 1110 helped me reinforce my understanding of basic Python syntax and computing principles. Furthermore, I gained the critical skill of explaining my thoughts to students who might not know the subject.

- __Recruiting for Internship__

    Recruiting for an internship was equivalent to a four credit class. I will expand more upon it in a separate blog. Recruiting added a lot of stress to an already stressful semester.

<!-- - Reasearch (Dropped) -->

### Reflection

Credits: 19

As if I had learned nothing the previous semester, I continued to overload myself this semester. I chose to take five heavy STEM classes in addition to recruiting for an internship. Each of these classes was a large amount of work individually, but together they became very hard to manage. Having around 3-4 problem sets due a week made diving deeper into any subject difficult. Additionally, I hadn't been recruited for an internship prior, so it was a learning experience doing leetcode and learning to apply to places consistently. This semester was by far the most challenging regarding my stress levels. Each day I would constantly be swamped with the number of problem sets I had to complete, exams I had to prepare for, and the constant threat that I wouldn't get an internship. 

## Spring 2022 Difficulty: Medium

- __ARKEO 2668: Ancient Egyptian Civilization__  
    <span style="color:grey">Christopher Monroe</span>

    My philosophy for engineering liberal studies has always been to choose the most accessible classes. This class is no different. The class consists of a weekly post on Canvas and three multiple-choice exams. The workload for the class was minimal, which allowed me to divert much of my attention to my other classes.

    The class covers Egyptian history up until the last Egyptian dynasty. Overall, the class provided me with a free A+ and was a liberal study requirement to graduate. 

- __ECE 3140/ CS 3420: Embedded Systems__  
    <span style="color:grey">Nils Napp</span>

    As the second part of the ECE 2300 -> CS 3420 path, the class was easy. However, I felt like there was a lot left on the table. The course covers basic assembly and calling conventions and includes basic threads and concurrency. The class isn't taught the best, and I wish there were a little more engagement other than the weekly async videos and quizzes.

    The projects covered within the class aren't that helpful in understanding the topics covered. Additionally, working on the board felt somewhat awkward because of the lack of support for the hardware. The final project requires you to use the board meaningfully to build a physical embedded system. 

    Besides the infrequent projects and weekly lecture quizzes, I didn't put much work into the class. The project partners are randomly assigned, which can also lead to issues. If I didn't need to take an ENGRD (2300), I definitely would've rather chosen to take 3410 strictly from the amount of material I would learn. I enjoy the systems component of Computer Science, so this class was moderately a letdown. However, if you want to get the systems requirement out of the way and don't need 2300, then you can take this course. While it won't help your learning as much, it is an option. Luckily in ENGRD 2300, I believe that the Verilog you learn in the course and the various foundational principles make up for the lack of material covered within this class. 

- __CS 4700: Foundations of Artificial Intelligence__  
    <span style="color:grey">Kevin Ellis & Haym Hirsh</span>

    I took this class because I still didn't have enough background to take the more advanced systems classes, and I needed another technical elective that I would find easy. However, this class was a lot harder than in previous semesters. The professors changed the course structure by incorporating additional content, which unfortunately resulted in a more superficial coverage of the topics and a lack of overall direction.

    The course content jumped from Bayesian reasoning to search algorithms, then to Markov models, supervised learning, and propositional logic. This rapid progression made it difficult to develop a solid foundation in any of the subjects, as we would barely scratch the surface of one topic before moving on to the next unrelated topic.

    Moreover, several newly introduced assignments were not thoroughly tested and seemed disconnected from the material we had covered. Although not excessively difficult, these assignments consumed significant time to complete. They encompassed both Python programming projects and written assignments.

    Throughout the course, many other classmates also complained about the course due to the unfair grading scheme, the 15-page prelim, or the unresponsiveness of TAs. 

    I believe my experience in CS 4700 only reflects that semester, as I heard the class has gotten a bit better with different professors and a more revised content schedule.

- __CS 4670: Introduction to Computer Vision__  
    <span style="color:grey">Bharath Hariharan</span>

    Similar to CS 4700, I wanted to take a few easier classes alongside CS 4820. Unlike CS 4700, the class was actually easy. The curriculum primarily focused on older aspects of computer vision, such as edge and line detection, which was somewhat disappointing considering we only touched on modern convolutional neural networks in the final week.

    The class consists of four projects that aren't too difficult. I chose to work with a partner, which greatly reduced the overall stress level of the course. In addition to projects, we had one prelim and a final. The final was moved online, which made the median very high. I believe that more recent offerings of the course have become even easier because both exams are online.

    I would describe my learning experience in this class as a solid foundation in image detection basics. However, the course content lacks practical applications for modern computer vision. Instead, it primarily focuses on the historical development of computer vision over the past few decades. Overall, it was an enjoyable class that didn't significantly add to the stress in my schedule.

- __üëç CS 4820: Intro Analysis of Algorithms__  
    <span style="color:grey">Eshan Chattopadhyay</span>

    The second to last required class for CS majors. As many people have said, the class is quite a bit of work. There are weekly problem sets and multiple programming assignments. Conceptually, the topics were not too difficult. We covered greedy algorithms, dynamic programming, NP-Completeness network flow, and Turing machines. 

    There is a prevailing belief among many students that completing this class is essential for securing internships. While some of the greedy and dynamic programming algorithms covered are indeed useful, several other algorithms covered, such as network flow, tend to be beyond the scope of most interview requirements. In my opinion, CS 2110 provides a sufficient foundation to begin seeking internships.

    Personally, I fairly enjoyed the course, and I never felt too stressed about it. However, this may be due to the fact that I had time to focus a large majority of my time on the class. 

- __üëç ECE 3100: Probability and Inference__  
    <span style="color:grey">Qing Zhao</span>

    I took another probability class because I felt like I didn't learn enough from BTRY 3080, and I wanted to fulfill my ECE external spec with another 3k+ ECE class. Like BTRY 3080, the topics covered basic Bayesian logic, components of set theory, normal distributions, and other statical tests. 

    I enjoyed the course more than BTRY because the professor was a lot more fun, her lectures were clearer, and the homework (although more) was closely tied to the source material. Additionally, a few programming assignments were a fun addition to simulating probability results.

    There was even a final project provided where we had to simulate the spread of Covid-19 and model it through Python code. However, I think the final project has gotten discontinued since I took the class.

    The one downside to the class is how the difficulty scales throughout the semester. The content covered for the first 4/5 of the class was very straightforward, but the content got a lot harder for the final exam. As a result, the previous exam medians of 80% became 50% for the final. However, I don't think the difficulty of the last part of the course detracts from the overall content and learning I received throughout the course. 

- __TA for CS 1110__

    Same as Previous Semesters

### Reflection

Credits: 22

Despite the seemingly intense semester with five STEM classes and one liberal study, the semester was a lot easier than the previous semester. CS 4670, CS 3420, and ARKEO 2668 were small amounts of work for an easy grade. As a result, I only spent time doing the remaining three courses. Initially, I had heard that CS 4700 was easy, but it turned out that they revamped the course with the new professor and made it astronomically harder. 

For CS 4820 and ECE 3100, it was always a consistent amount of work studying for exams and doing the problem sets.

I was lucky enough to get an interview for Amazon in early spring, where I landed the internship successfully. I ended up going to Amazon the following summer for my sophomore summer.

<!-- ## Summer 2022

### Reflection -->

## Fall 2022 Difficulty: Medium

- __üëç CS 2024: C++ Programming__  
    <span style="color:grey">Ronald DiNapoli</span>

    This course offers a manageable workload and serves as an introduction to the fundamentals of C++. However, your level of engagement and effort in the class will directly impact your learning experience. There is a weekly programming assignment that builds upon the previous week's assignment. Each week, you incorporate the things you learned into your small program. Additionally, the two exams are similar to the practice exams. 

    The course was taught relatively well, and I enjoyed attending the class. Reviewing the slides before class to understand the material better as the professor discusses the topics is helpful. 

    I mostly decided to take this class because I need two more advisor-approved electives. Additionally, as I became interested in competitive programming, I recognized the value of gaining a deeper understanding of C++. Since Cornell does not offer a dedicated course on this programming language, this class allowed me to expand my knowledge in that area.

- __üëç CS 4410: Operating Systems__  
    <span style="color:grey">Lorenzo Alvisi</span>

    The core backbone of all modern computers. Operating Systems cover concurrency, threads, virtual memory, and file systems. There is a lot of content throughout the semester, and often some things can't be covered because there is so much material.

    One area of improvement is the reinforcement of class content through homework and projects. There seems to be a scarcity of assignments, which hinders establishing a robust learning environment. I haven't taken OS practicum, but integrating it into the CS 4410 curriculum would enhance the course's overall quality. Students would have more opportunities to solidify their understanding by requiring practical applications alongside theoretical concepts.

    On the other hand, the content is taught pretty well by Professor Alvisi. The class is interesting and provides much insight into how modern Operating Systems handle the underlying hardware. I may be biased, but I enjoy the content of systems courses. As a result, I spent a lot of time outside of class reading the OSTEP book for interview prep and for this class. 

    Overall, system courses, including Operating Systems, align well with my aptitude and interests. The intricate interplay between hardware and software has always captivated me, and I appreciate the opportunity to delve into this domain.

- __üëç CS 4780: Introduction to Machine Learning__  
    <span style="color:grey">Anil Damle & Wen Sun</span>

    The introduction machine learning course at Cornell is great for getting your feet wet. The course requires a strong foundation in linear algebra, probability, and logical reasoning. Topics in the course range from perceptron, MLE/MAP, Naive Bayes, Kernels, and deep learning. The class covers a breadth of different machine-learning topics. However, the wide variety of topics doesn't stop the class from diving deep into each topic it covers. As a result, it is a much better introduction class than CS 4700.

    There were weekly problem sets and eight different programming projects. Each problem set and programming assignment closely follows the topics covered within the class, allowing students to reinforce their knowledge. 

    In summary, the class provides a solid introduction to machine learning for anybody that plans to take more advanced courses in ML. 

- __‚≠ê ECE 4750/ CS 4420 Computer Architecture__  
    <span style="color:grey">Christopher Batten</span>

    By far my favorite class of the semester, Professor Batten's Computer Architecture course is one the best ECE/CS courses at Cornell. The class covers topics that build upon each other, eventually leading to how modern advanced processors work. The courses cover instruction scheduling, pipelining, and branch prediction. However, one aspect that could be improved is the allocation of time. We spent significant time reviewing core ECE 2300 topics, limiting our exploration of other fascinating subjects.

    The workload for this class is undeniably heavy, with lectures and discussion sections held every week. Despite the demanding nature of the course, Professor Batten's teaching methodology stands out as the best I have encountered during my time at Cornell. With a class size of approximately 90 students, he distributes empty lecture notes that he fills in during class, allowing us to follow along effectively. He actively calls on students within the class and diligently listens to students' questions. The engagement within the class is unparalleled in other courses. In other classes, sometimes I would feel tired and have a hard time listening, but I never felt that in this class. Each topic covered was concise as he walked us through examples on the notes sheet. The lectures were amazing and shouldn't be missed. 

    Outside the lectures, we had four significant labs, a variable latency multiplier, a fully pipelined processor, a blocking cache, and a multi-core processor with a network. These labs are pretty heavy and require a lot of Verilog to complete. The labs are partner based, but the labs are in an awkward state where there is barely enough work to split, but if you work with a partner, you lose out on learning core pieces of Verilog. The labs tested how programmers code in hardware. The methodology for coding is drastically different, and you will need to change how you think to build these systems. 

    For exams, there are practice problems without any solutions. Initially, I thought this was weird, but spending time with other students digging through the questions with others helped my fundamental understanding of the topics covered within class. The exams are long but fair in relation to the practice problems received. 

    Overall, the class is extremely well organized, the professor is amazing, and the content is captivating. I highly recommend this class to anyone interested in lower-level systems and hardware. I thoroughly enjoyed the entire class, and it helped me understand the underlying hardware I'm programming on and improve my Verilog knowledge.

- __PLBIO 2400: Green World, Blue Planet__  
    <span style="color:grey">Tom Silva</span>

    By far the easiest class I have ever taken at Cornell. The class only had a weekly discussion section where we wrote 300 words for the topic we covered and sat in class for Poll everywhere. For exams, you can either take the multiple choice, written, or oral exam. I chose to do the oral exam. Opting for the oral exam, I engaged in a ten-minute discussion with the professor, responding to his inquiries about the topics covered in class. The extent I studied was cramming the day prior before the oral exam and landing a 100 each time. 

    Overall, this class not only delivered on its promise of being remarkably effortless but also served as a delightful addition to my academic journey at Cornell.

- __TA for CS 1110 (CS 4090)__  

    Same as in Previous Semesters, except this semester, I took TA for credit to fulfill some credit requirements.

- __Recruiting for Internship__  

    With my internship concluding at Amazon in the prior summer, I began recruiting starting in the summer. Similar to last year, I spent a large majority of my time recruiting for internships during the semester. I ended up taking two fewer courses to make sure I had enough time to recruit. I can't stress the importance of recruiting early. There were many people I knew that didn't end up getting the internships they desired because they started late and didn't prepare well enough. Personally, I ended up landing an internship at Citadel Securities, where I will be working on the Low Latency Software/FPGA Engineering Team.

### Reflection

Credits: 16

As a junior, I can finally take the computer science courses I enjoy after taking the required introductory system courses. ECE 4750 was the most enjoyment I've had at Cornell. During this semester, I had a large mentality shift toward the classes I've taken and the classes I plan to take. Despite the heavy workload posed by some classes, these classes are often the most rewarding in terms of content and the sheer material you learn. Alongside these classes, recruiting took up to five hours a day, depending on how many interviews I lined up. Ensuring your fall semester is a lighter workload is important for securing that internship.

## Spring 2023 Difficulty: Hard/Death

- __‚≠ê CS 5414: Distributed Computing Principles__  
    <span style="color:grey">Lorenzo Alvisi</span>

    This class is probably the most conceptually difficult systems course at Cornell. Professor Alvisi powerfully expresses his passion for this research area through his lectures. The content is challenging, often reflecting the difficulties of building and maintaining real-world distributed systems. 

    The course consists of three foundational distributed computing principles: Consistency, Consensus, and Reliability. The professor delves deep into these topics covering how people sought to build large-scale distributed systems using these principles and providing the theory behind these systems. 

    As the professor mentions, there are two basic approaches to distributed computing: cover many interesting systems, and distill from them fundamental principles, or focus on a deep understanding of the fundamental principles and see them instantiated in a few systems. 
    The class follows the latter. As a result, the class covers a lot of protocols about consensus and consistency.

    In my opinion, the best part of the class was the labs. Four labs build upon each other. These labs are challenging and take students, on average, 50 hours to complete the later ones. On top of that, the labs require a keen understanding of the underlying system and a distributed method of thinking. You need to ensure that each line of code you write is as you intended. Often, you are writing the sender and receiver code within a single function and need to consider all data interleavings.

    For the final two labs: Paxos and Shard Key/Value Store, many students in the class couldn't finish the labs because either they started too late, didn't understand the protocol, or there was a deeply nested bug within their code. I spent countless hours with my partner digging through execution files to find the exact interleaving that broke our code. As one of the few people in the class to finish all the labs, it was an incredibly rewarding experience.

    CS 5414 is a much take class for every single CS major. In our modern world, everything is a distributed system, and learning the fundamentals of how these systems work is invaluable to any future work in the industry.

- __‚≠ê CS 4120 + CS 4121: Introduction to Compilers + Practicum__  
    <span style="color:grey">Andrew Myers</span>

    Compilers is an infamous class for the sheer workload, and I would say it lives up to fame. Everybody in the class is passionate and ready to dedicate their time to completing the compiler. Professor Myers does an excellent job of teaching the fundamentals of compiler workflows, and he enriches the room with his insight into the various topics. 

    While CS 5414 might be the most conceptually difficult class I've taken, compilers is the heaviest workload class I've taken at Cornell by a mile. The core of the class consists of building a full compiler with a command line from scratch for a language similar to Java. Compilers is the first class at Cornell, where I felt you needed a strong team to succeed. Our resulting compiler is about 20k lines of Java. The course covers the full compilation process from lexing, parsing, and type checking to assembly generation and optimizations. 

    For future students of compilers, my most important message is finding a good team of four that works well together. You want a balance of people who are strong leaders and followers. I know teams who struggled because all four members were super strong, and nobody could agree with anybody else ideas. On the other hand, there were groups where the entire compiler design rested upon a single person's shoulders. I believe two people with strong design skills are perfect, with two others who can listen and follow the design these people set up. With two designers, each one can bounce ideas off one other without ever feeling burnt out. 

    Personally, I did a large majority of our compiler's design and implementation. Sometimes, my team would be blocked when I didn't know how to design a class or an overarching system our compiler would follow. However, I believe that everybody on the team was invaluable in the project's overall completion. 

    My favorite component of the class was the final assignment, where we built optimizations for our compiler. I spent weeks building optimizations that would improve the runtime of our compiler and tested our runtime against other teams in the compiler bakeoff. It formed a sense of competition that drove me to keep iterating upon our compiler and put in those extra optimizations. 

    Similar to the CMU compiler course, a running joke I saw mentioned was that many teams spend a long time implementing SSA, only for the implementation not to be as beneficial as it could be. We spent around a full week implementing the form, only to realize that many of the more complex optimizations would be hard to implement because there were many edge case bugs within our intermediate representation. As a result, we worked very carefully to work around these bugs but still tried to incorporate as many optimizations as possible. I did most of the optmizations for the compiler resulting in my group having the fastest compiler in the class as well as one of the groups with the highest correctness.
    
    The class is by far the most work I have ever put into a class. There were many weeks where I would spend over 30 hours tweaking bits of our compiler, working with my team, or adding another optimization. I thoroughly enjoyed the entire class, and the amount of code I wrote has made me a better programmer. A strong recommendation from me!

- __üëç CS 4414: Systems Programming__  
    <span style="color:grey">Ken Birman</span>

    To fulfill Cornell's systems requirements, students must take CS 4410 or CS 4414. I think CS 4410 is much more theoretical, whereas CS 4414 is a much more applied system. Both classes have their upside and downsides. 

    In CS 4410, your focus is much more on threads, virtual memory, and filesystems. Your projects are based around these topics, and you spend much of the semester learning the foundations of these core system topics. 

    In CS 4414, Professor Birman covers many topics important to becoming a good system programmer. He teaches about systems performance, threads, large-scale industrial systems, C++, and memory hierarchy basics. There isn't an overarching cohesive message towards the class, which makes me believe it is a better secondary course to CS 4410. Professor Birman's freedom to choose these topics due to their importance for performance-based code has opened my eyes to various methods of improving your code. Furthermore, the projects covered in class are more about improving the performance of your C++ capabilities by using Gprof to notice hot spots and reduce the time your program takes to run. 

    I thoroughly enjoyed both courses, and I recommended people take CS 4410 and CS 4414 for those interested in coding with C++ and reinforcing their knowledge about systems-based programming.

- __ECE 5725: Embedded operating Systems__  
    <span style="color:grey">Joseph Skovira</span>

    Due to the enormous amount of CS 5414 and CS 4120 work, I chose the lowest workload ECE class that could count towards my external spec. That class ended up being ECE 5725. The workload consisted of weekly four-hour lab sessions throughout the entire semester. Outside the lab, homework assignments and the occasional lab report seldom existed. After the labs ended, we also needed to do a final project. 

    The main crux of the class was the raspberry pi. Each lab utilized a physical component of the raspberry pi, such as the buttons screen or CPU. The class was very formulaic, but it was the class I needed to take to focus all my time on distributed systems and compilers. Combined, those classes took every single spare hour of the week I had. The class is quite fun and a good relaxing couple of hours each week within the lab.

- __ENGRC 3350: Organizational Communication for Engineers__  
    <span style="color:grey">Rick Evans</span>

    I never understood why Cornell makes second-semester seniors do product work for the NYSG. Within the class, many of the other students were in full senioritis mode. As a result, work would often get delayed; nobody wanted to do any work, including me.

    However, the workload wasn't light either. We had to write over 15 work logs, textbook responses, and emails to our clients and build a product for them. Luckily, my team members and I could push through and deliver on the work required to finish the class. 

    The engineering communication class is a requirement for all engineers and counts as a liberal study. I was lucky enough that my teammates were very helpful in finishing the required work before the deadline so that I could focus my time on other courses. There is a lot of busy work within the class that you constantly need to remind yourself to do.

- __TA for CS 4410__

    I wanted to TA CS 4410 because I started getting bored of TAing CS 1110. Additionally, the students in CS 1110 started to feel more and more dependent on the TAs rather than doing any of the work themselves. As a result, I decided to branch out and TA CS 4410 because I was interested in operating systems and wanted to refresh my knowledge on the topic. 

### Reflection

Credits: 19

Although this semester's workload was far greater than my other death semester (sophomore fall), the sheer enjoyment and fun I had within these classes significantly eased the amount of stress caused by the workload. Furthermore, I didn't have to constantly think about not having a job the following summer, which caused a lot of stress. This semester, there were many times were I would sit down at my computer beginning to work on compilers. At 9 am, I would blink, and it would be 5 pm. I had the most fun and pain this semester through these classes. I loved compilers and distributed computing. For this semester, I coded over 20000 lines of Java, and it pushed my limits. Despite its challenges, this semester was by far the most rewarding experience. I encourage everyone not to avoid difficult classes but embrace them. Distributed Computing and Compilers are two of the best CS courses offered at Cornell, and people shouldn't miss them!

<!-- ## Summer 2023

### Reflection

#### Three Things I Learned -->

## Fall 2023 Difficulty: Hard
- __üëç ECE 5775: High Level Digital Design Automation__  
    <span style="color:grey">Zhiru Zhang</span>

    This semester, I had the pleasure of attending my favorite class, which delved into the intersection of software-style programming and hardware constructs. The primary focus was on High-Level Synthesis (HLS), a methodology employing conventional software techniques to generate Verilog code, thereby enhancing the landscape for hardware design. This approach introduces innovative concepts and presents a fresh perspective on merging software and hardware realms.

    One of the most engaging aspects of the course was the extensive hands-on learning opportunities, particularly through multiple C-based labs. These practical sessions were instrumental in exploring the mapping of C-level constructs onto hardware, experimenting with loop unrolling, pipelining designs, and creating smaller hardware-resembling modules.

    However, the course did have its drawbacks, notably the perceived distance from real-world applicability in hardware or software design. Verilog, commonly utilized in practical hardware development due to its granular control over hardware elements, stood in contrast to the HLS methodology taught in the class. Despite this, I firmly believe that HLS is an intriguing concept. It grants software programmers a valuable glimpse into the intricacies of hardware development, providing a bridge between these seemingly disparate domains.

    Overall, the course remains a worthwhile endeavor. The insights gained into HLS and its implications offer valuable knowledge and broaden perspectives, making it a valuable investment of time and effort throughout the semester.

- __CS 5154: Software Testing__  
    <span style="color:grey">Owolabi Legunsen</span>

    The course primarily delves into the foundational concepts of software testing, exploring various methodologies and approaches. Despite being centered on software testing, the emphasis leans heavily towards theoretical aspects rather than practical implementation. A notable absence of hands-on coding within the class detracted from illustrating the practical benefits of software testing techniques.

    Exams largely focused on rote memorization of covered topics, diverting attention from applied understanding and skill development. However, the course did shed light on the effective partitioning of test cases to comprehensively address potential faults in code‚Äîan insightful takeaway from the theoretical teachings.

    In terms of workload, the class was relatively light and didn't demand an extensive time commitment, which allowed for better flexibility, particularly in balancing recruitment efforts. While the course provided a foundational understanding of test case partitioning and software testing theories, a more balanced approach with practical coding demonstrations could have significantly enriched the learning experience and demonstrated the tangible advantages of software testing methodologies.

- __CS 5320: Introduction to Database Systems__  
    <span style="color:grey">Immanuel Trummer</span>

    I spent 7 hours before each HW and Exam to get a 100%. They really need to revamp this class. 
    In the meantime, its been a breeze. I spent a total of 50 hours all semester on everything for this class and ended with basically a 100%. This class became a cramming session where I would cram the material and do well on the exams. 

- __CS 6230: Advanced Topics in Parallel Computing__  
    <span style="color:grey">Guilia Guidi</span>

    The course primarily centered around extensive paper readings, with weekly student presentations covering 3-4 papers on parallel computing. Each session featured two student presentations focusing on various aspects of parallel computing, particularly its intersections with machine learning and communication advancements. The culmination of the course involved a personalized research project.

    This PhD-level class operated on a self-driven learning approach, where your engagement determined the depth of your understanding. Overall, it offered a valuable academic experience. Yet, a more hands-on coding component throughout the semester, beyond the final research project, would have been beneficial. The absence of required coding limited practical application opportunities, which are often vital in reinforcing theoretical knowledge in parallel computing.

- __CS 6850: The Structure of Information Networks__  
    <span style="color:grey">Jon Kleinberg</span>

    This PhD-level course delves into captivating subjects within information theory and networks. Unlike the parallel computing class, this one adopts a more lecture-oriented approach to impart knowledge. The content covered in the lectures was intriguing, exploring complex facets of information theory and network dynamics.

    Regrettably, my engagement in the course was somewhat limited due to concurrent recruitment obligations. Despite this, the course's structure, characterized by a manageable workload and infrequent assignments, offered flexibility. This allowed me to navigate through the occasional homework and reports as they arose, ensuring I could maintain pace with the course while managing external commitments.

    While I found the topics covered in the class fascinating, I wished I could have devoted more time and engagement to delve deeper into the material. Nonetheless, the course structure and lighter workload accommodated the demands of simultaneous responsibilities, offering a manageable yet insightful academic experience in information theory and networks.

- __PE 1520: Archery__  
    <span style="color:grey">Julie Nathanielsz</span>

    A fun PE during the middle of the day on fridays. The class is very stress-free. 
    Arrows go Brrrrgh. 

- __Recruiting for Full Time__  

    Navigating full-time job recruitment was significantly more demanding than internships. Securing a suitable location added complexity to the search. I explored opportunities across various companies catering to recent graduates, ultimately receiving multiple offers this semester. It was an intense process, involving approximately 5-10 hours of interviews weekly, accompanied by 20-30 hours dedicated to preparation and reflection. Unfortunately, this focus on recruitment overshadowed my academic pursuits, impacting my learning this semester. The sheer pressure and demands of the recruitment journey are hard to overstate; it placed an immense strain on me as an individual. I wouldn't want to put myself in this situation again, but it has to be done. 

- __TA for CS 4410__  

    TA for CS 4410 is fun. As a result, I kept being a TA for CS 4410. The concepts are very interesting, and I think it is a good class to be a TA for. 

### Reflection

Credits: 17

This semester, the academic workload for my classes fell within the range of medium difficulty. Yet, the true challenge lay in juggling this workload alongside the demands of recruiting. While my classes maintained a moderate level of challenge, they inevitably assumed a secondary role as recruiting took the spotlight. Initially, I expected the recruiting process to span a month or two. However, within the current economic landscape, the timeline stretched far beyond my projections, leaving my classes in a state of uncertainty.

I found myself steering through the semester on cruise control, allocating more attention and time to the recruitment endeavors. As the weeks unfolded, the recruiting process persisted, expanding its influence on my schedule. It became a continuous endeavor, each passing week extending the duration, leaving my academic pursuits hanging in limbo.

Eventually, after navigating the exhaustive recruitment journey, I could finally shift my focus back to concluding my classes. It was a relief to wrap up both the intense recruiting phase and the academic commitments that had been sidelined during this time.

I don't have a lot to say about my classes because I didn't focus too much on classes this semster. 

## Spring 2024 Difficulty: Medium/Hard
- __CS 5152: Advanced Game Architecture__  
    <span style="color:grey">Walker White</span>

    Why did I take this class? I got bored. This is not a good reason to take this class. My opinions on this class are very mixed, and your mileage will vary depending on your team and your interest in the game. I will mainly be discussing the Programming aspect of the course. There is an alternative side of the course that mainly deals with assets for the game, like UI, character designs, etc. For the class overview, each team of ten is tasked with creating a fun, technical, and polished game. Throughout the semester, you will be using C++ for all programming. The semester starts with three smaller programming assignment labs that are pass-fail for regular students and graded for master's students. C++ is mainly modern C++ that uses shared pointers and managed memory management. Furthermore, we use a Cornell game library called CUGL. After the three labs, you begin iterating on your game until the end of the semester at the game showcase. 

    This class is very hit or miss. On top of that, there are a ton of highs and lows that occur on every team. My experience of the class is very mixed. I joined a team that had worked together on the introductory game development course. Having an experienced team helped initially, as they were very helpful in getting me caught up to speed on how to write documents, how to work sprints, and the overall direction of how the class would go. The initial part of the class where we didn't work on the game went smoothlyly; we discussed ideas for the game, finished the labs, and wrote up some initial documents. This phase of the class didn't prepare me for the remainder of the semester. Before the drop deadline, I would either drop this class or CS 4110, but because game development was better then, I ended up sticking it out in this course. My stress in the semester was that I didn't like this decision after the drop deadline. 

    In the middle part of the semester, the workload started to increase. On a team of ten with six programmers, it is hard to find work for everyone to do without people personally bringing up what they want to work on. Although I wasn't the programming lead, I became the defacto programming lead because a few other programmers were "busy" with other classes. As a result, I ended up being the one that drove the direction of the game, delegated programming tasks and kept everyone in check. On teams where people do work, having this more managerial role wouldn't be that big of a chore. However, I not only had to pick up this managerial role but also had to write about 85% of the codebase. While a few of the programmers did the jobs assigned in a timely manner, other programmers either weren't working up to expectations, didn't do anything, or were even actively causing negative work towards the team. While at the beginning, I tolerated this lack of progress, it slowly began to irritate me as work wasn't getting done, we were falling behind on progress, and I kept having to do the majority of the entire project. In addition to the lack of team cohesion and a lack of work, the type of coding within the project wasn't the most interesting. In compilers, there was a lot of coding, and the coding was very intellectually stimulating and promoted good design practices. There wasn't as much coding in distributed computing, but it was challenging and delicate. Within this class, the type of coding was very much monkey see, monkey do.

    Furthermore, the codebase being in C++ led to more challenges for other programmers. There were a few memory leaks, uneeded copies, and many other issues that led to severe performance issues in the game. The type of coding is very accustomed to the term code monkey. There would be an overall codebase structure I would have to think about, but the core gameplay of the game used a few classes that all interacted together. 

    The final sprints of the class were even worse. Programmers continuously had more and more excuses for not working on the code. A few of the programmers even dropped off the face of the earth. As we arrived at the last sprint, people finally started doing work because peer evaluations were brought up and became a real deterrent towards laziness. However, because I wrote the large majority of the codebase, every single programmer had to build off of my work, leading to constant questions and no ownership for many of the programmers. Throughout the semester, there was an expectation that I would end up doing most of the coding work, which led to people not putting in their time or effort into the class. While these thoughts don't reflect all the programmers on my team, the added stress from managing other people into doing the minimal work required resulted in slower development time for me. If this had just been a partner project, this game could've been coded up in a maximum of two weeks. However, the extreme amounts of overhead contributed to a hard struggle. One of the largest struggles is the different work styles of people; I consistently like to get work done as early as possible as it allows us to work towards other goals and make any changes as required. However, many other programmers either loved to wait until the last minute to do the work or didn't know how to approach problems. As a result, I would have to stress and wait for them to ask me more questions about the codebase rather than incrementally develop as the days passed, leading me to have to stay up for all-nighters we shouldn't have had to do given the work down throughout the sprint.

    The few bright moments in the class include learning more aspects of software engineering management as well as work delegation. The work I did as a programming lead was better than all the engineering management classes at Cornell because of the real-world application of people's different working and communication styles. Furthermore, because I ended up doing a lot of coding, I fine-tuned my C++ skills because of the amount of code I wrote. While I wouldn't take this class ever again, it was a positive experience that taught me many things about software team communication and longer-term project goals. 

    To succeed in game development, team communication, and work styles backed up with a good idea for a game are the most important things. By enforcing stricter deadlines and tight team coordination, disputes can be solved faster, programming can be iterated faster, and assets can be integrated quicker. A few of my biggest regrets within the class are not taking on the programming lead sooner and enforcing stricter deadlines, not enforcing work accomplishments by certain dates, and delegating work to establish ownership for each individual. 

- __CS 5411: Practicum in Operating Systems__
    <span style="color:grey">Robbert VanRenesse</span>

    The class is pretty interesting and has some decent work throughout the semester. There are five programming assignments that don't require too much programming, as there is a lot of wrapper code around the few functions that you have to write. One downside of the extreme amount of wrapper code is that the programmer might not understand what all the wrapper code of the OS is doing, leading to minimal learning. I believe that if the assignments had more coding, they would greatly help the enjoyment of the course. 

    One interesting thing about the course is that it feels like CS 4410 (OS), and this class should be combined into a single class. OS needs more work to justify the three credits, while CS 4411 feels more than a two-credit class. I believe both classes should be combined into one and made a four-credit class similar to other core classes within the programming curriculum. All CS students should take OS, but they often learn nothing because there is no work within that class. Combining these two classes would bring OS back to core class status and give the students a strong opportunity to learn about the concepts covered within the class. Nobody will remember anything that is covered in the class without programming applications. 

    The class focuses on memory management, C-based data structures, and file systems. While the coding is too long, the limited coding does teach you the nuances of C-style programming and allows you to explore the concepts that are covered within OS. Taking this class without OS is cool but is relatively easy and requires little time. Overall, it's a decent class that should be combined with OS. 

- __CS 5456: Introduction to Computer Networks__
    <span style="color:grey">Rachee Singh</span>

    This class is interesting... The entire class has almost no work, and you barely learn anything. The class is run poorly and unclear, and the grading scheme is horrible. The medians on assignments are always 100, the median of exam 1 (70/80), the median of exam 2 (90/100), and the median of the final (72/100). With exams and homework having such high medians, you would expect the class to have a high median for the class. However, rather than admitting fault in their grading scheme and poor distribution of students by giving out higher grades, or choosing to give harder exams and more challenging homework resulting in lower grades, they just curved down everybody. I got substantially above the median on every exam and received a grade I didn't expect. Furthermore, the exams are all fill-in-the-blanks or multiple-choice, leaving no room for error. A single mistake will jump you from above the median to below the median.

    I hate the inconsistency of the class; there is so much potential for this class. If you look at CMU's networks class, people learn to code servers and interact with network sockets. Furthermore, there is a more significant focus on modern networks and how modern computer networks work. In this class, we do about 20 minutes of coding all semester, and we barely cover anything about how modern networks operate. This class is amazing for the average, below-average, or lazy student in Computer Science at Cornell. You do not work, get an ok grade, and get four credits for doing nothing. If you are interested in computer networks, want to learn anything about networks, or care about your grades, absolutely avoid this class with a passion. A 3-day course on Udemy, which I crammed during the fall break of junior year, teaches more than this course. 

    What did I learn in this class? Nothing. 
    What taste did this class leave in my mouth? Nothing good. 

- __‚≠ê CS 5220: Applied High-Performance and Parallel Computing__
    <span style="color:grey">Giulia Guidi</span>

    One of my favorite classes at Cornell. While not excessively difficult, there is a considerable amount of work. There is nearly always a programming assignment during the week, and the class is based on CS 267. The assignments, which are very practical and cover actual programming applications, are a key highlight of the course. The class mainly focuses on parallel programming and the concepts allowing faster programs. These include hardware assembly optimizations, branch prediction, not using shared memory, and segmenting out fully parallel segments. The first assignment is optimizing a single threaded matrix multiplications. There are many tactics such as blocking, caching, and microkernels that can greatly optimize the speed of a matrix multiplication. I really liked this first assignment because it allowed me to peer into the actual assembly instructions being run, fine tuning optimizations to hit a desired target, and contintually iterating to improve the matrix computation. 

    The one minor critique of the class is the lectures themselves. Sometimes, they feel disconnected from what we are doing in the programming assignments. Overall, the lectures are good at teaching you various papers on parallel computing and certain techniques that are helpful for modern parallel computing. 

    However, I really enjoyed digging into the weeds and trying out more and more optimizations to improve the speed of the design. The programming within the course is very practical, using C++, MPI, UPI, and CUDA. These languages are widely used in the industry, making the course highly relevant to real-world applications. For parallel programming, seeing each of the paradims is very interseting in how to adapt a single problem into each of these platforms. The strongest part of this class is 100% the programming assignments. There is always work to do, and each of the programming assignments is interesting and allows the programmer to explore each of the programming paradigms. Furthermore, I really enjoy the fast feedback loop behind the execution of your code and the correct result. The multiple autograders, speed calculation all lead to a very streamlined class strucutre. Finally, unlike networks, the grading scheme is very straightforward. There are clear benchmarks to hit for your grade, and each of these benchmarks is challenging to hit. However, it is very rewarding to incrementally see your score increase as you put more time into each assignment. One of the most rewarding classes for application-based programmers at Cornell. 

- __CS 5110: Programming Languages & Logics (Dropped)__
    <span style="color:grey">Adrian Sampson</span>

    For the month I was in the class, it was a pretty interesting class. It teaches you the fundamentals of how and why programming languages exist and the theory behind the semantics. I dropped the class because nearly ten other people I knew also dropped the course. Furthermore, I didn't need the credits to graduate with my MEng. As a result, I decided to want an easier semester, which didn't pan out because I had to spend all of my time on Advanced Game Architecture. This is the second class I've ever dropped at Cornell. 

- __TA for CS 4410__

    TA for CS 4410 is fun/easy. I decided to TA the class again. Similar to previous semesters. It is interesting to see the same ed questions pop up every semester. 

### Reflection

Credits: 20 -> 16

I initially planned this semester to be very chill because I didn't need that many courses to graduate with my MEng. Furthermore, I didn't want to take that many interesting classes. However, my choice of taking game development proved to add a large amount of stress throughout the entire semester. While I came out of the semester unscathed, I wouldn't say I had the greatest time at Cornell for my last semester. The highlight of the semester was parallel computing, and whenever an assignment would be released, I put a large amount of hours into the class because I enjoyed the material. I would continually try to improve my code and would spend hours digging through small changes in the hope of improvement. A large chunk of my time this semester was covered with game dev. 